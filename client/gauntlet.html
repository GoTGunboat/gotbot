<!DOCTYPE html>
<!--
Created using JS Bin
http://jsbin.com

Copyright (c) 2017 by glorat (http://jsbin.com/hohaden/23/edit)

Released under the MIT license: http://jsbin.mit-license.org
-->
<meta name="robots" content="noindex">
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Glorat's Gauntlet Crew Optimiser</title>
<style id="jsbin-css">
.skill { width: 3.5em }
.crit { width: 2.5em }
</style>
</head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.0/angular.min.js"></script>
<link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet" type="text/css" />

<body ng-app="myApp" ng-controller="myCtrl as vm" class="container-fluid">
  <h1>Glorat's Gauntlet Crew Optimiser</h1>
  <div class="row">
    Add as many of your crew into this table with the appropriate skill ranges and crit %.
    Then use the checkboxes to select who you want to participate in the Gauntlet.
    Press the Analyse button and it will calculate a blended strength rating of your crew!
    Try different combinations to see which set of crew gives the highest strength and use that for your gauntlet.
  </div>
    <div class="row">
The results table then shows every possible skill combo, your best character for that combo, and the average points a full strength crew person will get in a typical round. The final is then a weighted average adjusted by the featured skill set (if you select one). I.e. the final number is your average unfatigued score given the random choice of skill combos  </div>

  <div>
    <select ng-options="user.username for user in vm.users track by user._id" ng-model="vm.selectedUser" ng-change="vm.onSelectedUserChange()"></select>
  </div>

  <div ng-repeat="char in vm.chars" class="row">
  <div class="col-sm-3 col-lg-2">
    <input type="checkbox" ng-model="char.selected">
    <input type="text" ng-model="char.name" size="10">
    Crit: <input type="number" ng-model="char.crit" class="crit">%
  </div>
    <div class="col-sm-3 col-lg-2" ng-repeat="skill in char.skills">
      <select ng-options="sk for sk in vm.skills" ng-model="skill.name"></select>
      <input type="number" ng-model="skill.min" class="skill">-<input type="number" ng-model="skill.max" class="skill">
    </div>

  </div>
  <div>
    <button ng-click="vm.addChar()">Add</button>
    <button ng-click="vm.removeChar()">Remove</button>
  </div>
  <div>
    Featured Skill: <select ng-options="sk for sk in vm.skills" ng-model="vm.featuredSkill"></select>
  </div>
  <div>
        <button ng-click="vm.selectBest()">Select Top Chars</button>
    <button ng-click="vm.analyse()">Analyse Selected</button>
    <button ng-click="vm.analyseAll()">Analyse Combinations of Selected</button>
    <button ng-click="vm.reset()">Reset</button>
  </div>
  <div>
    <div ng-repeat="row in vm.result">
      {{ row[0] }} {{ row[1].name  }} {{ vm.comboAvg(row[1], row[0]) | number:0 }}
    </div>
    <div>
      Total: {{vm.total | number:0}}
    </div>
  </div>
  <div>
    <div ng-repeat="res in vm.fullRes" class="row">
      <div class="col-xs-1">{{ res.total | number:0 }}</div>
      <div class="col-xs-2" ng-repeat="nm in res.names">{{nm}}</div>
    </div>
  </div>
  <div class="row">
    <div class="col-xs-12">
      <textarea class=".form-control" ng-model="vm.chars | json"></textarea>
    </div>

  </div>
<script id="jsbin-javascript">
angular
  .module("myApp", [])
  .controller("myCtrl", function($scope, $http, Combinatorics, Gauntlet) {

    var charIdx = 0;
    function newChar() {
      return {
        name:'Char ' + ++charIdx,
        crit:5,
        selected:true,
        skills : [
          {name:'Cmd', min:0, max:0},
          {name:'Dip', min:0, max:0},
          {name:'Sec', min:0, max:0}
        ]
      };
    }

    var vm = this;
    vm.skills = ['Cmd','Dip','Eng','Sec','Med','Sci'];
    vm.featuredSkillWeight = 2.0;

    var saved = (typeof localStorage === 'object') ? localStorage.getItem('crew') : '';
    if (!saved) {saved = '';}
    if (saved !== '') {
       vm.chars = JSON.parse(saved) ;
    }
    else {
       resetCrew();
    }

    vm.reset = resetCrew;

    $http({
      method: 'GET',
      url: '/users'
    }).then(function successCallback(response) {
      vm.users = response.data;
    }, function errorCallback(response) {
      // called asynchronously if an error occurs
      // or server returns response with an error status.
    });

    function resetCrew() {
      vm.chars = [0,1,2,3,4].map(newChar);
    }

  function save() {
    localStorage.setItem('crew', JSON.stringify(vm.chars));

  }

    vm.comboAvg = Gauntlet.comboAvg;

    vm.analyse = function() {
      save();
      var selectedChars = _.filter(vm.chars, c=>c.selected);

      var res = Gauntlet.analyseChars(selectedChars, vm.featuredSkill, vm.featuredSkillWeight);
      vm.result = res.result;
      vm.total = res.total;
    };

    vm.addChar = function() {
      vm.chars.push(newChar());
    };

    vm.removeChar = function() {
      vm.chars.pop();
    };

    vm.analyseAll = function() {
      save();
      var selectedChars = _.filter(vm.chars, c=>c.selected);
      var res = Gauntlet.analyseCharCombos(selectedChars, vm.featuredSkill, vm.featuredSkillWeight);
      vm.fullRes = res;
    };

    vm.selectBest = function() {
      var best = Gauntlet.topChars(vm.chars, vm.featuredSkill, vm.featuredSkillWeight);

      _.each(vm.chars,
        char => char.selected = _.contains(best, char.name)
      );
    };

    vm.onSelectedUserChange = function() {

      $http({
        method: 'GET',
        url: `/user/${vm.selectedUser._id}`
      }).then(function successCallback(response) {
        const user = response.data;

        function dbCharToChar(dbChar) {
          var char = {};
          char.name = dbChar.name;
          char.crit = 5;
          char.selected = true;

          char.skills = _.chain(vm.skills)
            .filter(function(sk){return !!dbChar[sk.toLowerCase()];})
            .map(function(sk){return {name:sk, min: dbChar[sk.toLowerCase()].minroll, max:dbChar[sk.toLowerCase()].maxroll};})
            .value();

          return char;
        }

        if (user.crew.length>0) {
          vm.chars = _.map(user.crew, dbCharToChar);
        }

      }, function errorCallback(response) {
        // called asynchronously if an error occurs
        // or server returns response with an error status.
      });


    };




  });


angular
  .module("myApp").service('Gauntlet', function(Combinatorics) {

  const skills = ['Cmd','Dip','Eng','Sec','Med','Sci'];

  return {
    skills : skills,

    comboAvg:comboAvg,
    analyseChars: analyseChars,
    analyseCharCombos: analyseCharCombos,
    topChars: topChars
  };

  function topChars(chars, featuredSkill, featuredSkillWeight) {
    var res = analyseChars(chars, featuredSkill, featuredSkillWeight);
    var nms = res.result.map(x => x[1].name);
    return _.uniq(nms);
  }

  function analyseCharCombos(chars, featuredSkill, featuredSkillWeight) {

    //noprotect
    var cmb = Combinatorics.combination(chars, 5);
    var res = [];

      while( cmbChars = cmb.next()) {
        var rec = analyseChars(cmbChars, featuredSkill, featuredSkillWeight);
        var summary = {names:cmbChars.map(c => c.name), total:rec.total};
        res.push(summary);
      }

    // sort in descending total order
    res = _.sortBy(res, x => -x.total);

    return res;
  }

  function analyseCharsOld(chars, featuredSkill, featuredSkillWeight) {

    var result = squareCombo(skills, analyseCombo, chars);

      var denom=0.0;
      var sum = _.reduce(result, function(a,b){
        var featured = _.contains(b[0], featuredSkill);

        denom += featured ? featuredSkillWeight : 1.0;
        // Crits will double the skill value
        return a+ comboAvg(b[1],b[0]) * (featured ? 2.0 : 1.0 );
      },0);

    return {result:result, total:sum/denom};
  }

  function analyseChars(chars, featuredSkill, featuredSkillWeight) {
    // strengths[skIdx][charIdx] = strength

    // Step 1: Unfatigued strengths
    var strengths = [];
    var skillCombos = squareCombo(skills, sk => sk);

  for (var j=0; j<skillCombos.length;j++) {
    strengths[j] = [];
    for (var i=0; i<chars.length; i++) {
        strengths[j][i] = comboAvg(chars[i], skillCombos[j]);
      }
    }
    // Step 2: TODO: Produce fatigued strengths
    // This step is currently broken
    /*
    for (var charIdx=0; charIdx<chars.length; charIdx++) {
      // Descending order of best
      var charBestSkills = _.sortBy(_.range(skillCombos.length), skIdx=>{-strengths[skIdx][charIdx]});
      // Apply adjustment!
      for (var adjIdx=0; adjIdx<charBestSkills.length; adjIdx++) {
        // 20% fatigue factor per use
        var mult = 1 - (0.2 * adjIdx);
        mult = mult < 0 ? 0 : mult;
        strengths[adjIdx][charIdx] *= mult;
      }
    }*/
    var adjStrengths = strengths;

    // Step 3: Reduce to best char per sks
    var result = [];
    for (var j=0; j<skillCombos.length; j++) {
      var bestIdx = _.max(_.range(chars.length), charIdx => adjStrengths[j][charIdx]);
      var best = chars[bestIdx];
      result.push([skillCombos[j], best]);
    }

    // Step 4: Compute totals
          var denom=0.0;
      var sum = _.reduce(result, function(a,b){
        var featured = _.contains(b[0], featuredSkill);

        denom += featured ? featuredSkillWeight : 1.0;
        // Crits will double the skill value
        return a+ comboAvg(b[1],b[0]) * (featured ? 2.0 : 1.0 );
      },0);
    // Step 5: Return the required structure

    return {result: result, total: sum/denom};
  }

    function comboAvg (char, sks) {

      var crit = char.crit;
      return _.chain(char.skills)
      .filter(function(sk){return _.contains(sks, sk.name);})
      .map(function(sk){return (1+crit/100)*3*(sk.min+sk.max)/2;})
      .reduce(function(a,b){return a+b;}, 0)
      .value();
    }

    function squareCombo(arr, cb, foo) {
      var ret = [];
      for (var i=0; i<arr.length; i++) {
        for (var j=i+1; j<arr.length;j++) {
          ret.push(cb( [arr[i], arr[j]], foo ));
        }
      }
      return ret;
    }


    function bestCharForSkills(chars, sks) {
      return _.max(chars, function(char) {return comboAvg(char, sks);});
    }

    function analyseCombo(sks, chars) {
      var best = bestCharForSkills(chars, sks)
      return [sks, best];
    }

});

angular
  .module("myApp").service('Combinatorics', function() {

    var addProperties = function(dst, src) {
        Object.keys(src).forEach(function(p) {
            Object.defineProperty(dst, p, {
                value: src[p],
                configurable: p == 'next'
            });
        });
    };
    var hideProperty = function(o, p) {
        Object.defineProperty(o, p, {
            writable: true
        });
    };
    var P = function(m, n) {
        var p = 1;
        while (n--) p *= m--;
        return p;
    };
    var C = function(m, n) {
        if (n > m) {
            return 0;
        }
        return P(m, n) / P(n, n);
    };
    var nextIndex = function(n) {
        var smallest = n & -n,
            ripple = n + smallest,
            new_smallest = ripple & -ripple,
            ones = ((new_smallest / smallest) >> 1) - 1;
        return ripple | ones;
    };


var combination = function(ary, nelem, fun) {
        if (!nelem) nelem = ary.length;
        if (nelem < 1) throw new RangeError();
        if (nelem > ary.length) throw new RangeError();
        var first = (1 << nelem) - 1,
            size = C(ary.length, nelem),
            maxIndex = 1 << ary.length,
            sizeOf = function() {
                return size;
            },
            that = Object.create(ary.slice(), {
                length: {
                    get: sizeOf
                }
            });
        hideProperty(that, 'index');
        addProperties(that, {
            valueOf: sizeOf,
            init: function() {
                this.index = first;
            },
            next: function() {
                if (this.index >= maxIndex) return;
                var i = 0,
                    n = this.index,
                    result = [];
                for (; n; n >>>= 1, i++) {
                    if (n & 1) result[result.length] = this[i];
                }

                this.index = nextIndex(this.index);
                return (typeof (that._lazyMap) === 'function')?that._lazyMap(result):result;
            }
        });
        //addProperties(that, common);
        that.init();
        return (typeof (fun) === 'function') ? that.map(fun) : that;
    };

  return {
    combination:combination
  }
});



</script>
</body>
</html>
